#include<bits/stdc++.h>
using namespace std;

// This code is written by Anurag Mishra
// Time complexity : O(N^2) when the tree is skewed.

int search(char inorder[], char value, int start, int end)
{
    int i;
    for(i = start; i <= end; i++)
    {
        if(inorder[i] == value)
            return i;
    }
}
TreeNode* constructTree(char inorder[], char preorder[], int inStart, int inEnd)
{
    if(inStart > inEnd)
        return  NULL;
    
    static int first = 0;
    
    TreeNode* root  = newNode(preorder[first++]);
    
    if(inStart == inEnd)
        return root;
    
    int index =  search(inorder, root->data, inStart, inEnd);
    
    root->left = constructTree(inorder, preorder, inStart, index - 1);
    root->right = constructTree(inorder, preorder, index + 1, inEnd);
    
    return root;
    
    /*
    
    char inorder[] = { 'D', 'B', 'E', 'A', 'F', 'C' }; 
    char preorder[] = { 'A', 'B', 'D', 'E', 'C', 'F' }; 
    */
}

===============Efficient Solution===============


